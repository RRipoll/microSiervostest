# GitLab CI/CD Pipeline for TestJava Price Service

stages:
  - validate
  - test
  - quality
  - build
  - security
  - deploy-staging
  - performance
  - deploy-production

variables:
  JAVA_VERSION: "17"
  GRADLE_OPTS: "-Dorg.gradle.daemon=false -Dorg.gradle.parallel=true -Dorg.gradle.configureondemand=true"
  GRADLE_USER_HOME: "$CI_PROJECT_DIR/.gradle"
  MAVEN_OPTS: "-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository"

# Cache configuration
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - .gradle/wrapper
    - .gradle/caches
    - build/

# Base template for Java jobs
.java-base: &java-base
  image: openjdk:17-jdk-slim
  before_script:
    - apt-get update -qq && apt-get install -y -qq git curl
    - chmod +x ./gradlew
    - export GRADLE_USER_HOME=`pwd`/.gradle

# Fast validation stage
validate:
  <<: *java-base
  stage: validate
  script:
    - echo "ðŸ” Validating project structure and dependencies..."
    - ./gradlew dependencies --quiet
    - ./gradlew compileJava compileTestJava --build-cache
  artifacts:
    expire_in: 1 hour
    paths:
      - build/classes/
  only:
    - branches
    - merge_requests

# Unit Tests - Fast Feedback
unit-tests:
  <<: *java-base
  stage: test
  script:
    - echo "ðŸ”„ Running unit tests..."
    - ./gradlew fastTest --continue --build-cache
  coverage: '/Total.*?([0-9]{1,3})%/'
  artifacts:
    expire_in: 1 week
    when: always
    reports:
      junit:
        - build/test-results/unitTest/TEST-*.xml
      coverage_report:
        coverage_format: jacoco
        path: build/reports/jacoco/unitTest/jacocoTestReport.xml
    paths:
      - build/reports/tests/unitTest/
      - build/reports/jacoco/unitTest/
  only:
    - branches
    - merge_requests

# API Tests - REST Endpoints
api-tests:
  <<: *java-base
  stage: test
  needs: ["validate"]
  script:
    - echo "ðŸŒ Running API tests..."
    - ./gradlew validateApi --continue --build-cache
  artifacts:
    expire_in: 1 week
    when: always
    reports:
      junit:
        - build/test-results/apiTest/TEST-*.xml
    paths:
      - build/reports/tests/apiTest/
  only:
    - branches
    - merge_requests

# Integration Tests - Full Flow
integration-tests:
  <<: *java-base
  stage: test
  needs: ["unit-tests", "api-tests"]
  script:
    - echo "ðŸ”— Running integration tests..."
    - export SPRING_PROFILES_ACTIVE=test
    - ./gradlew integrationTest --continue --build-cache
  artifacts:
    expire_in: 1 week
    when: always
    reports:
      junit:
        - build/test-results/integrationTest/TEST-*.xml
    paths:
      - build/reports/tests/integrationTest/
  only:
    - branches
    - merge_requests

# Code Quality Analysis
code-quality:
  <<: *java-base
  stage: quality
  needs: ["unit-tests"]
  script:
    - echo "ðŸ›¡ï¸ Running code quality analysis..."
    - ./gradlew fullTest jacocoTestReport --continue --build-cache
    - ./gradlew testCoverageReport
    - |
      if [ -n "$SONAR_TOKEN" ]; then
        echo "Running SonarQube analysis..."
        ./gradlew sonar --continue
      else
        echo "âš ï¸  SonarQube token not configured, skipping analysis"
      fi
  coverage: '/Total.*?([0-9]{1,3})%/'
  artifacts:
    expire_in: 1 week
    when: always
    reports:
      junit:
        - build/test-results/test/TEST-*.xml
      coverage_report:
        coverage_format: jacoco
        path: build/reports/jacoco/test/jacocoTestReport.xml
    paths:
      - build/reports/
  allow_failure: true
  only:
    - branches
    - merge_requests

# Build Application
build:
  <<: *java-base
  stage: build
  needs: ["integration-tests"]
  script:
    - echo "ðŸ—ï¸ Building application..."
    - ./gradlew build -x test --build-cache --scan
    - echo "ðŸ“¦ Application built successfully"
    - ls -la build/libs/
  artifacts:
    expire_in: 1 week
    paths:
      - build/libs/*.jar
      - build/distributions/*
  only:
    - branches
    - merge_requests

# Security Scanning
security-scan:
  <<: *java-base
  stage: security
  needs: ["build"]
  script:
    - echo "ðŸ”’ Running security analysis..."
    - ./gradlew dependencyCheckAnalyze --continue || true
    - echo "ðŸ” Checking for known vulnerabilities..."
  artifacts:
    expire_in: 1 week
    when: always
    paths:
      - build/reports/dependency-check-report.html
  allow_failure: true
  only:
    - branches
    - merge_requests

# Docker Build
docker-build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  needs: ["build"]
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - echo "ðŸ³ Building Docker image..."
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:latest
    - echo "âœ… Docker image pushed successfully"
  only:
    - main
    - develop

# Deploy to Staging
deploy-staging:
  stage: deploy-staging
  image: alpine:latest
  needs: ["build", "code-quality"]
  environment:
    name: staging
    url: https://staging.testjava-priceservice.com
  before_script:
    - apk add --no-cache curl
  script:
    - echo "ðŸš€ Deploying to staging environment..."
    - echo "Application version: $CI_COMMIT_SHA"
    - |
      # This would typically deploy to your staging infrastructure
      # Example: kubectl, Helm, or deployment scripts
      echo "Staging deployment simulated"
    - echo "âœ… Staging deployment completed"
  after_script:
    - echo "ðŸ”¥ Running staging smoke tests..."
    - curl -f https://staging.testjava-priceservice.com/actuator/health || echo "âš ï¸  Health check failed"
  only:
    - develop
  when: manual

# Performance Tests
performance-tests:
  <<: *java-base
  stage: performance
  needs: ["deploy-staging"]
  script:
    - echo "ðŸš€ Running performance tests..."
    - ./gradlew performanceTest --continue
  artifacts:
    expire_in: 1 month
    when: always
    paths:
      - build/reports/tests/performanceTest/
  allow_failure: true
  only:
    - develop
    - schedules
  when: manual

# Deploy to Production
deploy-production:
  stage: deploy-production
  image: alpine:latest
  needs: ["build", "code-quality", "security-scan"]
  environment:
    name: production
    url: https://testjava-priceservice.com
  before_script:
    - apk add --no-cache curl
  script:
    - echo "ðŸŒŸ Deploying to production environment..."
    - echo "Application version: $CI_COMMIT_SHA"
    - |
      # This would typically deploy to your production infrastructure
      # Example: kubectl, Helm, or deployment scripts
      echo "Production deployment simulated"
    - echo "âœ… Production deployment completed"
  after_script:
    - echo "â¤ï¸ Running production health checks..."
    - curl -f https://testjava-priceservice.com/actuator/health || echo "âš ï¸  Health check failed"
    - echo "ðŸ“Š Deployment metrics collected"
  only:
    - main
  when: manual

# Scheduled Jobs
dependency-update:
  <<: *java-base
  stage: validate
  script:
    - echo "ðŸ”„ Checking for dependency updates..."
    - ./gradlew dependencyUpdates
  artifacts:
    expire_in: 1 week
    paths:
      - build/dependencyUpdates/
  only:
    - schedules
  when: manual

# Cleanup old artifacts
cleanup:
  stage: .post
  image: alpine:latest
  script:
    - echo "ðŸ§¹ Cleaning up old artifacts..."
    - echo "Cleanup completed"
  when: always
  allow_failure: true

# Job templates for different environments
.deploy-template: &deploy-template
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Deploying to $ENVIRONMENT..."
    - echo "Version: $CI_COMMIT_SHA"
  after_script:
    - echo "Health check for $ENVIRONMENT"